# Sum up the individual digits
digit_sum <- sum(as.numeric(strsplit(clean_string, "")[[1]], na.rm = TRUE))
# Print the sum of the digits
print(digit_sum)
# Calculate factorial of a number
factorial <- function(n) {
if (n <= 1) {
return(1)
} else {
return(n * factorial(n - 1))
}
}
# Calculate the factorial of 100
factorial_100 <- factorial(100)
# Convert the factorial number to a character string
factorial_string <- as.character(factorial_100)
# Remove any non-digit characters from the string
clean_string <- gsub("[^0-9]", "", factorial_string)
# Sum up the individual digits
digit_sum <- sum(as.numeric(strsplit(clean_string, "")[[1]], na.rm = TRUE))
# Print the sum of the digits
print(digit_sum)
for(n in 2:100) {
num.vect <- as.integer(unlist(strsplit(as.character(n), "")))
myprod <- mult_digits(myprod, num.vect)
}
# Problem 20: Factorial digit sum
#.. takes two digit vectors and returns product vector
mult_digits <- function(mydig1, mydig2) {
# define product vector
sumdig <- 0
# loop through each digit in mydig2
for(i in 1:length(mydig2)) {
sumdig.tmp <- mydig1 * mydig2[length(mydig2)-i+1]
# shift product 1 to the left for each digit and add
sumdig.tmp <- c(sumdig.tmp, rep(0, i-1))
sumdig <- c(rep(0,length(sumdig.tmp)-length(sumdig)),sumdig) + sumdig.tmp
# loop while digit value needs carry
while(!all(sumdig < 10)) {
carry <- c(sumdig %/% 10, 0)
if(carry[1]==0) carry <- carry[-1]
sumdig <- c(rep(0,length(carry)-length(sumdig)), sumdig%%10) + carry
}
}
return(sumdig)
}
#.. calculate factorial vector `myprod`
myprod <- 1
for(n in 2:100) {
num.vect <- as.integer(unlist(strsplit(as.character(n), "")))
myprod <- mult_digits(myprod, num.vect)
}
sum(myprod)
# Calculate factorial of a number
factorial <- function(n) {
if (n <= 1) {
return(1)
} else {
return(n * factorial(n - 1))
}
}
# Calculate the factorial of 100
factorial_100 <- factorial(100)
# Convert the factorial number to a character string
factorial_string <- as.character(factorial_100)
# Sum up the individual digits
digit_sum <- sum(as.numeric(strsplit(factorial_string, "")[[1]]))
# Print the sum of the digits
print(digit_sum)
# Calculate factorial of a number
factorial <- function(n) {
if (n <= 1) {
return(1)
} else {
return(n * factorial(n - 1))
}
}
# Calculate the factorial of 100
factorial_100 <- factorial(100)
# Convert the factorial number to a character string
factorial_string <- as.character(factorial_100)
# Sum up the individual digits
digit_sum <- sum(as.numeric(strsplit(factorial_string, "")[[1]]))
# Print the sum of the digits
print(digit_sum)
no_repeats <- function(x,missing_digits){
# Returns BOOLEAN
# TRUE if x has no repeats and no digit is 0
# FALSE if x has repeat digits or any digits is 0
r <- rep(TRUE,length(x))
for(i in 1:length(x)){
dont_match <- missing_digits
while(x[i] > 0){
mod <- x[i] %% 10
if(mod == 0){
r[i] <- FALSE
}else if(sum(match(dont_match,mod),na.rm=TRUE) > 0){
r[i] <- FALSE
}
dont_match <- c(dont_match,mod)
x[i] <- x[i] %/% 10
}
}
return(r)
}
digits <- function(x){
d <- c()
while(x > 0){
d <- c(d,x %% 10)
x <- x %/% 10
}
return(rev(d))
}
poss_products <- 1234:9876
poss_products <- poss_products[no_repeats(poss_products,c())]
poss_factors1 <- 2:98 # Factor can't be 1
poss_factors1 <- poss_factors1[no_repeats(poss_factors1,c())]
total <- 0
for(product in poss_products){
is_pandigital <- FALSE
used <- digits(product)
f1 <- poss_factors1[no_repeats(poss_factors1,used)] # Remove factors w/ duplicates
f1 <- f1[product %% f1 == 0] # Remove non-factors
if(length(f1) > 0){ # If we have any left
f2 <- product / f1
for(i in 1:length(f1)){
dig_f1 <- digits(f1[i])
dig_f2 <- digits(f2[i])
# Check that no digits repeat, but that every digit is used
if(no_repeats(f2[i],c(used,dig_f1)) & length(c(used,dig_f1,dig_f2))==9){
is_pandigital <- TRUE
}
}
}
if(is_pandigital){
total <- total + product
}
}
print(total)
for(i in 1:length(all_primes)){
num <- all_primes[i]
if(nchars[i]==1){
circular_primes <- circular_primes + 1
}else{ # Only check if all digits are odd
shifts <- 1
not_prime <- 0
while(shifts < nchars[i] & not_prime == 0){
num <- (num %/% 10) + (num %% 10) * vec2[nchars[i]]
if(num %in% all_primes == FALSE){
not_prime <- 1
}
shifts <- shifts + 1
}
if(not_prime == 0){
circular_primes <- circular_primes + 1
}
}
}
no_repeats <- function(x,missing_digits){
# Returns BOOLEAN
# TRUE if x has no repeats and no digit is 0
# FALSE if x has repeat digits or any digits is 0
r <- rep(TRUE,length(x))
for(i in 1:length(x)){
dont_match <- missing_digits
while(x[i] > 0){
mod <- x[i] %% 10
if(mod == 0){
r[i] <- FALSE
}else if(sum(match(dont_match,mod),na.rm=TRUE) > 0){
r[i] <- FALSE
}
dont_match <- c(dont_match,mod)
x[i] <- x[i] %/% 10
}
}
return(r)
}
digits <- function(x){
d <- c()
while(x > 0){
d <- c(d,x %% 10)
x <- x %/% 10
}
return(rev(d))
}
poss_products <- 1234:9876
poss_products <- poss_products[no_repeats(poss_products,c())]
poss_factors1 <- 2:98 # Factor can't be 1
poss_factors1 <- poss_factors1[no_repeats(poss_factors1,c())]
total <- 0
for(product in poss_products){
is_pandigital <- FALSE
used <- digits(product)
f1 <- poss_factors1[no_repeats(poss_factors1,used)] # Remove factors w/ duplicates
f1 <- f1[product %% f1 == 0] # Remove non-factors
if(length(f1) > 0){ # If we have any left
f2 <- product / f1
for(i in 1:length(f1)){
dig_f1 <- digits(f1[i])
dig_f2 <- digits(f2[i])
# Check that no digits repeat, but that every digit is used
if(no_repeats(f2[i],c(used,dig_f1)) & length(c(used,dig_f1,dig_f2))==9){
is_pandigital <- TRUE
}
}
}
if(is_pandigital){
total <- total + product
}
}
print(total)
max_num <- 999999L
all_nums <- c(1L:(max_num+1))
nchars <- ceiling(log10(all_nums + 1))
all_nums[1] <- 0L
vec1 <- 10^(1:7)
vec2 <- vec1/10
for(i in 2L:max_num){
if(all_nums[i] != 0){
all_nums[seq.int(min(max_num+1,i*2),length(all_nums),i)] <- 0
digits <- (i %% vec1[nchars[i]:1]) %/% vec2[nchars[i]:1]
if(sum(digits %% 2 == 0 | digits == 5) != 0 & nchars[i] > 1){
all_nums[i] <- 0
}
}
}
all_primes <- all_nums[all_nums!=0]
nchars <- ceiling(log10(all_primes + 1))
# Check each to see if shifted digits are also prime
circular_primes <- 0
for(i in 1:length(all_primes)){
num <- all_primes[i]
if(nchars[i]==1){
circular_primes <- circular_primes + 1
}else{ # Only check if all digits are odd
shifts <- 1
not_prime <- 0
while(shifts < nchars[i] & not_prime == 0){
num <- (num %/% 10) + (num %% 10) * vec2[nchars[i]]
if(num %in% all_primes == FALSE){
not_prime <- 1
}
shifts <- shifts + 1
}
if(not_prime == 0){
circular_primes <- circular_primes + 1
}
}
}
vec1 <- 10^(1:7)
for(i in 1:length(all_primes)){
num <- all_primes[i]
if(nchars[i]==1){
circular_primes <- circular_primes + 1
}else{ # Only check if all digits are odd
shifts <- 1
not_prime <- 0
while(shifts < nchars[i] & not_prime == 0){
num <- (num %/% 10) + (num %% 10) * vec2[nchars[i]]
if(num %in% all_primes == FALSE){
not_prime <- 1
}
shifts <- shifts + 1
}
if(not_prime == 0){
circular_primes <- circular_primes + 1
}
}
}
print(answer)
print(answer)
source("Euler/euler.R")
rotate <- function (v) {
l <- length(v)
if (l != 1) {
w <- (1:l) + 1
w[w > l] <- 1
}
v <- v[w]
return (v)
}
primes <- esieve(1e6)
answer <- 0
t <- proc.time()
for (n in primes) {
digs <- as.numeric(unlist(strsplit(as.character(n), "")))
circular.prime <- TRUE
if (n > 9) {
if (!any(digs %% 2 == 0)) {
for (i in 1:(length(digs) - 1)) {
digs <- rotate(digs)
if (!is.prime(as.numeric(paste0(digs, collapse=""))))
circular.prime <- FALSE
}
} else circular.prime <- FALSE
}
if (circular.prime) answer <- answer + 1
}
print(proc.time() - t)
print(answer)
answer <- 0
source("euler.R")
rotate <- function (v) {
l <- length(v)
if (l != 1) {
w <- (1:l) + 1
w[w > l] <- 1
}
v <- v[w]
return (v)
}
primes <- esieve(1e6)
answer <- 0
t <- proc.time()
for (n in primes) {
digs <- as.numeric(unlist(strsplit(as.character(n), "")))
circular.prime <- TRUE
if (n > 9) {
if (!any(digs %% 2 == 0)) {
for (i in 1:(length(digs) - 1)) {
digs <- rotate(digs)
if (!is.prime(as.numeric(paste0(digs, collapse=""))))
circular.prime <- FALSE
}
} else circular.prime <- FALSE
}
if (circular.prime) answer <- answer + 1
}
print(proc.time() - t)
print(answer)
## Sieve of Eratosthenes for generating primes 2:n
esieve <- function(n) {
if (n == 1) return(NULL)
if (n == 2) return(n)
# Create a list l of consecutive integers {2,3,â€¦,N}.
l <- 2:n
# Start counter
i <- 1
# Select p as the first prime number in the list, p=2.
p <- 2
while (p^2 <= n) {
# Remove all multiples of p from the l.
l <- l[l == p | l %% p != 0]
# set p equal to the next integer in l which has not been removed.
i <- i + 1
# Repeat steps 3 and 4 until p2 > n, all the remaining numbers in the list are primes
p <- l[i]
}
return(l)
}
rotate <- function (v) {
l <- length(v)
if (l != 1) {
w <- (1:l) + 1
w[w > l] <- 1
}
v <- v[w]
return (v)
}
primes <- esieve(1e6)
answer <- 0
t <- proc.time()
for (n in primes) {
digs <- as.numeric(unlist(strsplit(as.character(n), "")))
circular.prime <- TRUE
if (n > 9) {
if (!any(digs %% 2 == 0)) {
for (i in 1:(length(digs) - 1)) {
digs <- rotate(digs)
if (!is.prime(as.numeric(paste0(digs, collapse=""))))
circular.prime <- FALSE
}
} else circular.prime <- FALSE
}
if (circular.prime) answer <- answer + 1
}
print(proc.time() - t)
print(answer)
# take input from the user
nterms = as.integer(readline(prompt="How many terms? "))
# first two terms
n1 = 0
n2 = 1
count = 2
# check if the number of terms is valid
if(nterms)
5
Fibonacci <- numeric(10)
Fibonacci[1] <- Fibonacci[2] <- 1
for (i in 3:10) Fibonacci[i] <- Fibonacci[i - 2] + Fibonacci[i - 1]
print("First 10 Fibonacci numbers:")
print(Fibonacci)
Ms <- function(moving_sum) {
Fib <- numeric(moving_sum + 1) # Use the parameter moving_sum
Fib[1]  <- Fib[2] <- 1
for (i in seq(3, moving_sum + 1)) Fib[i] <- Fib[i - 2] + Fib[i - 1]
return(Fib[-1]) # Remove the first number
}
Ms(20)
sum <- 0
prev <- 1
current <- 2
sumevenfib <- function(limit) {
while (current <= limit) {
if (current %% 2 == 0) {
sum <- sum + current
}
fnext <- prev + current
prev <- current
current <- fnext
}
return(sum)
}
limit <- 4000000
answer <- sumevenfib(limit)
print(answer)
system("python 21UCA004/Textfile.py")
a = [1,2,3]
b =[2,4,6]
print (a+b)
import numpy as np
a= np.array([1,2,3])
print(a)
b= np array ([2,4,6])
print(b)
c=a+b
print(c)
c=a*b
print(c)
c=a/b
print(c)
a = [1,2,3]
b =[2,4,6]
print (a+b)
import numpy as np
a= np.array([1,2,3])
print(a)
b= np array ([2,4,6])
print(b)
c=a+b
print(c)
c=a*b
print(c)
c=a/b
a = [1,2,3]
b =[2,4,6]
print (a+b)
import numpy as np
a= np.array([1,2,3])
print(a)
b= np array ([2,4,6])
print(b)
c=a+b
print(c)
c=a*b
print(c)
c=a/b
library(jsonlite)
install.packages("jsonlite")
#A) How will you merge these two tables to create a single table
# Load necessary libraries
library(jsonlite)
library(XML)
library(readxl)
# Read data from JSON files
data_jsonF <- fromJSON("employee1.json")
install.packages("jsonlite")
#A) How will you merge these two tables to create a single table
# Load necessary libraries
library(jsonlite)
library(XML)
library(readxl)
# Read data from JSON files
data_jsonF <- read_json("employee1.json")
data <- read_json("employee1.json")
library(jsonlite)
library(XML)
library(readxl)
# Read data from JSON files
data <- read_json("employee1.json")
library(jsonlite)
# Read data from JSON files
data <- read_json("employee1.json")
getwd()
setwd()
setwd("D:/GitHub/DataScience_R_Lab/Lab")
library(jsonlite)
# Read data from JSON files
data <- read_json("employee1.json")
getwd()
getwd()
# Read data from JSON files
data <- read_json("employee1.json")
print(data)
library(jsonlite)
getwd()
# Read data from JSON files
data <- read_json("employee1.json")
print(data)
install.packages("jsonlite")
library(jsonlite)
# Check your working directory
getwd()
# Specify the full file paths or ensure that the JSON files are in your working directory
json_file1 <- "employees1.json"
json_file2 <- "employees2.json"
# Read data from JSON files
data_json1 <- fromJSON(json_file1)
data_json2 <- fromJSON(json_file2)
# Summary of the JSON data (if applicable)
summary(data_json1)
